{
  "version": 3,
  "sources": ["../src/index.ts", "../src/utils.ts", "../src/constants.ts", "../src/config.ts", "../src/manifest.ts"],
  "sourcesContent": ["import { basename, posix, resolve } from 'path'\nimport type { ConfigEnv, PluginOption, UserConfig, ViteDevServer } from 'vite'\nimport createDebugger from 'debug'\n\nimport { cleanConfig, configOptionFromEnv } from './utils'\nimport { filterEntrypointsForRollup, loadConfiguration, resolveGlobs } from './config'\nimport { assetsManifestPlugin } from './manifest'\nimport { UnifiedConfig } from './types'\n\nexport * from './types'\n\n// Public: The resolved project root.\nexport const projectRoot = configOptionFromEnv('root') || process.cwd()\n\n// Internal: Additional paths to watch.\nlet watchAdditionalPaths: string[] = []\n\n// Public: Vite Plugin to detect entrypoints in a Ruby app, and allows to load a shared JSON configuration file that can be read from Ruby.\nexport default function ViteRubyPlugin (): PluginOption[] {\n  return [\n    {\n      name: 'vite-plugin-ruby',\n      config,\n      configureServer,\n    },\n    assetsManifestPlugin(),\n  ]\n}\n\nconst debug = createDebugger('vite-plugin-ruby:config')\n\n// Internal: Resolves the configuration from environment variables and a JSON\n// config file, and configures the entrypoints and manifest generation.\nfunction config (userConfig: UserConfig, env: ConfigEnv): UserConfig {\n  const config = loadConfiguration(env.mode, projectRoot, userConfig)\n  const { assetsDir, base, outDir, host, https, port, root, entrypoints } = config\n\n  const fs = { allow: [projectRoot], strict: true }\n  const hmr = userConfig.server?.hmr ?? { host, port }\n  const server = { host, https, port, strictPort: true, fs, hmr }\n\n  const build = {\n    emptyOutDir: true,\n    sourcemap: config.mode !== 'development',\n    ...userConfig.build,\n    assetsDir,\n    manifest: true,\n    outDir,\n    rollupOptions: {\n      input: Object.fromEntries(filterEntrypointsForRollup(entrypoints)),\n      output: {\n        ...outputOptions(assetsDir),\n        ...userConfig.build?.rollupOptions?.output,\n      },\n    },\n  }\n\n  debug({ base, build, root, server, entrypoints: Object.fromEntries(entrypoints) })\n\n  watchAdditionalPaths = resolveGlobs(projectRoot, root, config.watchAdditionalPaths || [])\n\n  const alias = { '~/': `${root}/`, '@/': `${root}/` }\n\n  return cleanConfig({\n    resolve: { alias },\n    base,\n    root,\n    server,\n    build,\n    viteRuby: config,\n  })\n}\n\n// Internal: Allows to watch additional paths outside the source code dir.\nfunction configureServer (server: ViteDevServer) {\n  server.watcher.add(watchAdditionalPaths)\n}\n\nfunction outputOptions (assetsDir: string) {\n  // Internal: Avoid nesting entrypoints unnecessarily.\n  const outputFileName = (ext: string) => ({ name }: { name: string }) => {\n    const shortName = basename(name).split('.')[0]\n    return posix.join(assetsDir, `${shortName}.[hash].${ext}`)\n  }\n\n  return {\n    entryFileNames: outputFileName('js'),\n    chunkFileNames: outputFileName('js'),\n    assetFileNames: outputFileName('[ext]'),\n  }\n}\n", "import { readFileSync } from 'fs'\n\nimport { ENV_PREFIX } from './constants'\n\n// Internal: Returns true if the specified value is a plain JS object\nexport function isObject (value: unknown): value is Record<string, any> {\n  return Object.prototype.toString.call(value) === '[object Object]'\n}\n\n// Internal: Simplistic version that gets the job done for this scenario.\n// Example: screamCase('buildOutputDir') === 'BUILD_OUTPUT_DIR'\nexport function screamCase (key: string) {\n  return key.replace(/([a-z])([A-Z])/g, '$1_$2').toUpperCase()\n}\n\n// Internal: Returns a configuration option that was provided using env vars.\nexport function configOptionFromEnv (optionName: string) {\n  return process.env[`${ENV_PREFIX}_${screamCase(optionName)}`]\n}\n\n// Internal: Ensures it's easy to turn off a setting with env vars.\nexport function booleanOption<T> (value: 'true' | 'false' | boolean | T): boolean | T {\n  if (value === 'true') return true\n  if (value === 'false') return false\n  return value\n}\n\n// Internal: Returns the filename without the last extension.\nexport function withoutExtension (filename: string) {\n  const lastIndex = filename.lastIndexOf('.')\n  return lastIndex > -1 ? filename.substr(0, lastIndex) : filename\n}\n\n// Internal: Loads a json configuration file.\nexport function loadJsonConfig<T> (filepath: string): T {\n  return JSON.parse(readFileSync(filepath, { encoding: 'utf8', flag: 'r' })) as T\n}\n\n// Internal: Removes any keys with undefined or null values from the object.\nexport function cleanConfig (object: Record<string, any>) {\n  Object.keys(object).forEach((key) => {\n    const value = object[key]\n    if (value === undefined || value === null) delete object[key]\n    else if (isObject(value)) cleanConfig(value)\n  })\n  return object\n}\n", "// Internal: Inferred mode, since Vite doesn't yet expose it to its plugins.\nexport const APP_ENV = process.env.RAILS_ENV || process.env.RACK_ENV || process.env.APP_ENV\n\n// Internal: Prefix used for environment variables that modify the configuration.\nexport const ENV_PREFIX = 'VITE_RUBY'\n\n// Internal: Key of the vite.json file that is applied to all environments.\nexport const ALL_ENVS_KEY = 'all'\n\n// Internal: Extensions of CSS files or known precompilers.\nexport const KNOWN_CSS_EXTENSIONS = [\n  'css',\n  'less',\n  'sass',\n  'scss',\n  'styl',\n  'stylus',\n  'pcss',\n  'postcss',\n]\n\n// Internal: Types of files that Vite should process correctly as entrypoints.\nexport const KNOWN_ENTRYPOINT_TYPES = [\n  'html',\n  'jsx?',\n  'tsx?',\n  ...KNOWN_CSS_EXTENSIONS,\n]\n\nexport const CSS_EXTENSIONS_REGEX = new RegExp(\n  `\\\\.(${KNOWN_CSS_EXTENSIONS.join('|')})$`,\n)\n\nexport const ENTRYPOINT_TYPES_REGEX = new RegExp(\n  `\\\\.(${KNOWN_ENTRYPOINT_TYPES.join('|')})(\\\\?.*)?$`,\n)\n", "import { join, relative, resolve, isAbsolute } from 'path'\nimport glob from 'fast-glob'\n\nimport type { UserConfig } from 'vite'\nimport { APP_ENV, ALL_ENVS_KEY, CSS_EXTENSIONS_REGEX, ENTRYPOINT_TYPES_REGEX } from './constants'\nimport { booleanOption, loadJsonConfig, configOptionFromEnv } from './utils'\nimport { Config, ResolvedConfig, UnifiedConfig, MultiEnvConfig, Entrypoints } from './types'\n\n// Internal: Default configuration that is also read from Ruby.\nconst defaultConfig: ResolvedConfig = loadJsonConfig(resolve(__dirname, '../default.vite.json'))\n\n// Internal: Returns the files defined in the entrypoints directory that should\n// be processed by rollup.\n//\n// NOTE: For stylesheets the original extension is preserved in the name so that\n// the resulting file can be accurately matched later in `extractChunkStylesheets`.\nexport function filterEntrypointsForRollup (entrypoints: Entrypoints): Entrypoints {\n  return entrypoints\n    .filter(([_name, filename]) => ENTRYPOINT_TYPES_REGEX.test(filename))\n}\n\n// Internal: Returns the files defined in the entrypoints directory that are not\n// processed by Rollup and should be manually fingerprinted and copied over.\nexport function filterEntrypointAssets (entrypoints: Entrypoints): Entrypoints {\n  return entrypoints\n    .filter(([_name, filename]) => !ENTRYPOINT_TYPES_REGEX.test(filename))\n}\n\n// Internal: Returns the style files defined in the entrypoints directory that\n// are processed by Rollup but not included in the Vite.js manifest.\nexport function filterStylesheetAssets (entrypoints: Entrypoints): Entrypoints {\n  return entrypoints\n    .filter(([_name, filename]) => CSS_EXTENSIONS_REGEX.test(filename))\n}\n\n// Internal: Checks if the specified path is inside the specified dir.\nfunction isInside (file: string, dir: string) {\n  const path = relative(dir, file)\n  return path && !path.startsWith('..') && !isAbsolute(path)\n}\n\n// Internal: Returns all files defined in the entrypoints directory.\nfunction resolveEntrypointFiles (projectRoot: string, sourceCodeDir: string, { entrypointsDir, additionalEntrypoints }: ResolvedConfig): Entrypoints {\n  const inputGlobs = [`~/${entrypointsDir}/**/*`, ...additionalEntrypoints]\n  const resolvedGlobs = resolveGlobs(projectRoot, sourceCodeDir, inputGlobs)\n  return glob.sync(resolvedGlobs).map(filename => [\n    resolveEntryName(projectRoot, sourceCodeDir, filename),\n    filename,\n  ])\n}\n\n// Internal: All entry names are relative to the sourceCodeDir if inside it, or\n// to the project root if outside.\nexport function resolveEntryName (projectRoot: string, sourceCodeDir: string, file: string) {\n  return relative(isInside(file, sourceCodeDir) ? sourceCodeDir : projectRoot, file)\n}\n\n// Internal: Allows to use the `~` shorthand in the config globs.\nexport function resolveGlobs (projectRoot: string, sourceCodeDir: string, patterns: string[]) {\n  return patterns.map(pattern =>\n    resolve(projectRoot, pattern.replace(/^~\\//, `${sourceCodeDir}/`)),\n  )\n}\n\n// Internal: Loads configuration options provided through env variables.\nfunction configFromEnv (): Config {\n  const envConfig: Record<string, any> = {}\n  Object.keys(defaultConfig).forEach((optionName) => {\n    const envValue = configOptionFromEnv(optionName)\n    if (envValue !== undefined) envConfig[optionName] = envValue\n  })\n  return envConfig\n}\n\n// Internal: Allows to load configuration from a json file, and VITE_RUBY\n// prefixed environment variables.\nexport function loadConfiguration (viteMode: string, projectRoot: string, userConfig: UserConfig): UnifiedConfig {\n  const envConfig = configFromEnv()\n  const mode = envConfig.mode || APP_ENV || viteMode\n  const filePath = join(projectRoot, envConfig.configPath || (defaultConfig.configPath as string))\n  const multiEnvConfig = loadJsonConfig<MultiEnvConfig>(filePath)\n  const fileConfig: Config = { ...multiEnvConfig[ALL_ENVS_KEY], ...multiEnvConfig[mode] }\n\n  // Combine the three possible sources: env > json file > defaults.\n  return coerceConfigurationValues({ ...defaultConfig, ...fileConfig, ...envConfig, mode }, projectRoot, userConfig)\n}\n\n// Internal: Coerces the configuration values and deals with relative paths.\nfunction coerceConfigurationValues (config: ResolvedConfig, projectRoot: string, userConfig: UserConfig): UnifiedConfig {\n  // Coerce the values to the expected types.\n  config.port = parseInt(config.port as unknown as string)\n  config.https = userConfig.server?.https || booleanOption(config.https)\n\n  // Use the sourceCodeDir as the Vite.js root.\n  const root = join(projectRoot, config.sourceCodeDir)\n\n  // Vite expects the outDir to be relative to the root.\n  const buildOutputDir = join(config.publicDir, config.publicOutputDir)\n  const outDir = relative(root, buildOutputDir) // Vite expects it to be relative\n\n  // Add the asset host to enable usage of a CDN.\n  const assetHost = config.assetHost || ''\n  const assetHostWithProtocol = assetHost && !assetHost.startsWith('http') ? `//${assetHost}` : assetHost\n  const base = `${assetHostWithProtocol}/${config.publicOutputDir}/`\n\n  const entrypoints = resolveEntrypointFiles(projectRoot, root, config)\n  return { ...config, root, outDir, base, entrypoints }\n}\n", "import path from 'path'\nimport { promises as fsp } from 'fs'\nimport { createHash } from 'crypto'\nimport createDebugger from 'debug'\n\nimport type { Plugin, ResolvedConfig } from 'vite'\n\nimport { OutputBundle, PluginContext } from 'rollup'\nimport { UnifiedConfig } from '../dist'\nimport { filterEntrypointAssets, filterStylesheetAssets } from './config'\nimport { withoutExtension } from './utils'\n\nconst debug = createDebugger('vite-plugin-ruby:assets-manifest')\n\ninterface AssetsManifestChunk {\n  src?: string\n  file: string\n}\n\ntype AssetsManifest = Map<string, AssetsManifestChunk>\n\nfunction getAssetHash (content: Buffer) {\n  return createHash('sha256').update(content).digest('hex').slice(0, 8)\n}\n\n// Internal: Writes a manifest file that allows to map an entrypoint asset file\n// name to the corresponding output file name.\nexport function assetsManifestPlugin (): Plugin {\n  let config: ResolvedConfig\n  let viteRubyConfig: UnifiedConfig\n\n  // Internal: For stylesheets Vite does not output the result to the manifest,\n  // so we extract the file name of the processed asset from the Rollup bundle.\n  function extractChunkStylesheets (bundle: OutputBundle, manifest: AssetsManifest) {\n    const cssFiles = Object.fromEntries(filterStylesheetAssets(viteRubyConfig.entrypoints))\n\n    Object.values(bundle).filter(chunk => chunk.type === 'asset' && chunk.name)\n      .forEach((chunk) => {\n        // Vite will output a single CSS chunk named style.css\n        if (!config.build.cssCodeSplit && chunk.name === 'style.css')\n          return manifest.set(chunk.name, { file: chunk.fileName, src: chunk.name })\n\n        // NOTE: Rollup appends `.css` to the file so it's removed before matching.\n        // See `filterEntrypointsForRollup`.\n        const src = withoutExtension(chunk.name!)\n        const absoluteFileName = cssFiles[src]\n        if (absoluteFileName)\n          manifest.set(path.relative(config.root, absoluteFileName), { file: chunk.fileName, src })\n      })\n  }\n\n  // Internal: Vite ignores some entrypoint assets, so we need to manually\n  // fingerprint the files and move them to the output directory.\n  async function fingerprintRemainingAssets (ctx: PluginContext, bundle: OutputBundle, manifest: AssetsManifest) {\n    const remainingAssets = filterEntrypointAssets(viteRubyConfig.entrypoints)\n\n    for (const [filename, absoluteFilename] of remainingAssets) {\n      const content = await fsp.readFile(absoluteFilename)\n      const hash = getAssetHash(content)\n\n      const ext = path.extname(filename)\n      const filenameWithoutExt = filename.slice(0, -ext.length)\n      const hashedFilename = path.posix.join(config.build.assetsDir, `${path.basename(filenameWithoutExt)}.${hash}${ext}`)\n\n      manifest.set(path.relative(config.root, absoluteFilename), { file: hashedFilename, src: filename })\n\n      // Avoid duplicates if the file was referenced in a different entrypoint.\n      if (!bundle[hashedFilename])\n        ctx.emitFile({ name: filename, fileName: hashedFilename, type: 'asset', source: content })\n    }\n  }\n\n  return {\n    name: 'vite-plugin-ruby:assets-manifest',\n    apply: 'build',\n    enforce: 'post',\n    configResolved (resolvedConfig: ResolvedConfig) {\n      config = resolvedConfig\n      viteRubyConfig = (config as any).viteRuby\n    },\n    async generateBundle (_options, bundle) {\n      const manifest: AssetsManifest = new Map()\n      extractChunkStylesheets(bundle, manifest)\n\n      await fingerprintRemainingAssets(this, bundle, manifest)\n      debug({ manifest })\n\n      this.emitFile({\n        fileName: 'manifest-assets.json',\n        type: 'asset',\n        source: JSON.stringify(Object.fromEntries(manifest), null, 2),\n      })\n    },\n  }\n}\n"],
  "mappings": ";;;AAAA;AAEA;;;ACFA;;;ACCO,IAAM,UAAU,QAAQ,IAAI,aAAa,QAAQ,IAAI,YAAY,QAAQ,IAAI;AAG7E,IAAM,aAAa;AAGnB,IAAM,eAAe;AAGrB,IAAM,uBAAuB;AAAA,EAClC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAIK,IAAM,yBAAyB;AAAA,EACpC;AAAA,EACA;AAAA,EACA;AAAA,EACA,GAAG;AAAA;AAGE,IAAM,uBAAuB,IAAI,OACtC,OAAO,qBAAqB,KAAK;AAG5B,IAAM,yBAAyB,IAAI,OACxC,OAAO,uBAAuB,KAAK;;;AD7B9B,kBAAmB;AACxB,SAAO,OAAO,UAAU,SAAS,KAAK,WAAW;AAAA;AAK5C,oBAAqB;AAC1B,SAAO,IAAI,QAAQ,mBAAmB,SAAS;AAAA;AAI1C,6BAA8B;AACnC,SAAO,QAAQ,IAAI,GAAG,cAAc,WAAW;AAAA;AAI1C,uBAA2B;AAChC,MAAI,UAAU;AAAQ,WAAO;AAC7B,MAAI,UAAU;AAAS,WAAO;AAC9B,SAAO;AAAA;AAIF,0BAA2B;AAChC,QAAM,YAAY,SAAS,YAAY;AACvC,SAAO,YAAY,KAAK,SAAS,OAAO,GAAG,aAAa;AAAA;AAInD,wBAA4B;AACjC,SAAO,KAAK,MAAM,aAAa,UAAU,CAAE,UAAU,QAAQ,MAAM;AAAA;AAI9D,qBAAsB;AAC3B,SAAO,KAAK,QAAQ,QAAQ,CAAC;AAC3B,UAAM,QAAQ,OAAO;AACrB,QAAI,UAAU,UAAa,UAAU;AAAM,aAAO,OAAO;AAAA,aAChD,SAAS;AAAQ,kBAAY;AAAA;AAExC,SAAO;AAAA;;;AE7CT;AACA;AAQA,IAAM,gBAAgC,eAAe,QAAQ,WAAW;AAOjE,oCAAqC;AAC1C,SAAO,YACJ,OAAO,CAAC,CAAC,OAAO,cAAc,uBAAuB,KAAK;AAAA;AAKxD,gCAAiC;AACtC,SAAO,YACJ,OAAO,CAAC,CAAC,OAAO,cAAc,CAAC,uBAAuB,KAAK;AAAA;AAKzD,gCAAiC;AACtC,SAAO,YACJ,OAAO,CAAC,CAAC,OAAO,cAAc,qBAAqB,KAAK;AAAA;AAI7D,kBAAmB,MAAc;AAC/B,QAAM,QAAO,SAAS,KAAK;AAC3B,SAAO,SAAQ,CAAC,MAAK,WAAW,SAAS,CAAC,WAAW;AAAA;AAIvD,gCAAiC,cAAqB,eAAuB,CAAE,gBAAgB;AAC7F,QAAM,aAAa,CAAC,KAAK,uBAAuB,GAAG;AACnD,QAAM,gBAAgB,aAAa,cAAa,eAAe;AAC/D,SAAO,KAAK,KAAK,eAAe,IAAI,cAAY;AAAA,IAC9C,iBAAiB,cAAa,eAAe;AAAA,IAC7C;AAAA;AAAA;AAMG,0BAA2B,cAAqB,eAAuB;AAC5E,SAAO,SAAS,SAAS,MAAM,iBAAiB,gBAAgB,cAAa;AAAA;AAIxE,sBAAuB,cAAqB,eAAuB;AACxE,SAAO,SAAS,IAAI,aAClB,QAAQ,cAAa,QAAQ,QAAQ,QAAQ,GAAG;AAAA;AAKpD;AACE,QAAM,YAAiC;AACvC,SAAO,KAAK,eAAe,QAAQ,CAAC;AAClC,UAAM,WAAW,oBAAoB;AACrC,QAAI,aAAa;AAAW,gBAAU,cAAc;AAAA;AAEtD,SAAO;AAAA;AAKF,2BAA4B,UAAkB,cAAqB;AACxE,QAAM,YAAY;AAClB,QAAM,OAAO,UAAU,QAAQ,WAAW;AAC1C,QAAM,WAAW,KAAK,cAAa,UAAU,cAAe,cAAc;AAC1E,QAAM,iBAAiB,eAA+B;AACtD,QAAM,aAAqB,sBAAK,eAAe,gBAAkB,eAAe;AAGhF,SAAO,0BAA0B,wCAAK,gBAAkB,aAAe,YAAtC,CAAiD,QAAQ,cAAa;AAAA;AAIzG,mCAAoC,SAAwB,cAAqB;AAxFjF;AA0FE,UAAO,OAAO,SAAS,QAAO;AAC9B,UAAO,QAAQ,kBAAW,WAAX,mBAAmB,UAAS,cAAc,QAAO;AAGhE,QAAM,OAAO,KAAK,cAAa,QAAO;AAGtC,QAAM,iBAAiB,KAAK,QAAO,WAAW,QAAO;AACrD,QAAM,SAAS,SAAS,MAAM;AAG9B,QAAM,YAAY,QAAO,aAAa;AACtC,QAAM,wBAAwB,aAAa,CAAC,UAAU,WAAW,UAAU,KAAK,cAAc;AAC9F,QAAM,OAAO,GAAG,yBAAyB,QAAO;AAEhD,QAAM,cAAc,uBAAuB,cAAa,MAAM;AAC9D,SAAO,sBAAK,UAAL,CAAa,MAAM,QAAQ,MAAM;AAAA;;;AC1G1C;AACA;AACA;AACA;AASA,IAAM,QAAQ,eAAe;AAS7B,sBAAuB;AACrB,SAAO,WAAW,UAAU,OAAO,SAAS,OAAO,OAAO,MAAM,GAAG;AAAA;AAK9D;AACL,MAAI;AACJ,MAAI;AAIJ,mCAAkC,QAAsB;AACtD,UAAM,WAAW,OAAO,YAAY,uBAAuB,eAAe;AAE1E,WAAO,OAAO,QAAQ,OAAO,WAAS,MAAM,SAAS,WAAW,MAAM,MACnE,QAAQ,CAAC;AAER,UAAI,CAAC,QAAO,MAAM,gBAAgB,MAAM,SAAS;AAC/C,eAAO,SAAS,IAAI,MAAM,MAAM,CAAE,MAAM,MAAM,UAAU,KAAK,MAAM;AAIrE,YAAM,MAAM,iBAAiB,MAAM;AACnC,YAAM,mBAAmB,SAAS;AAClC,UAAI;AACF,iBAAS,IAAI,KAAK,SAAS,QAAO,MAAM,mBAAmB,CAAE,MAAM,MAAM,UAAU;AAAA;AAAA;AAM3F,4CAA2C,KAAoB,QAAsB;AACnF,UAAM,kBAAkB,uBAAuB,eAAe;AAE9D,eAAW,CAAC,UAAU,qBAAqB;AACzC,YAAM,UAAU,MAAM,IAAI,SAAS;AACnC,YAAM,OAAO,aAAa;AAE1B,YAAM,MAAM,KAAK,QAAQ;AACzB,YAAM,qBAAqB,SAAS,MAAM,GAAG,CAAC,IAAI;AAClD,YAAM,iBAAiB,KAAK,MAAM,KAAK,QAAO,MAAM,WAAW,GAAG,KAAK,SAAS,uBAAuB,OAAO;AAE9G,eAAS,IAAI,KAAK,SAAS,QAAO,MAAM,mBAAmB,CAAE,MAAM,gBAAgB,KAAK;AAGxF,UAAI,CAAC,OAAO;AACV,YAAI,SAAS,CAAE,MAAM,UAAU,UAAU,gBAAgB,MAAM,SAAS,QAAQ;AAAA;AAAA;AAItF,SAAO;AAAA,IACL,MAAM;AAAA,IACN,OAAO;AAAA,IACP,SAAS;AAAA,IACT,eAAgB;AACd,gBAAS;AACT,uBAAkB,QAAe;AAAA;AAAA,UAE7B,eAAgB,UAAU;AAC9B,YAAM,WAA2B,IAAI;AACrC,8BAAwB,QAAQ;AAEhC,YAAM,2BAA2B,MAAM,QAAQ;AAC/C,YAAM,CAAE;AAER,WAAK,SAAS;AAAA,QACZ,UAAU;AAAA,QACV,MAAM;AAAA,QACN,QAAQ,KAAK,UAAU,OAAO,YAAY,WAAW,MAAM;AAAA;AAAA;AAAA;AAAA;;;AJ9E5D,IAAM,cAAc,oBAAoB,WAAW,QAAQ;AAGlE,IAAI,uBAAiC;AAGtB;AACb,SAAO;AAAA,IACL;AAAA,MACE,MAAM;AAAA,MACN;AAAA,MACA;AAAA;AAAA,IAEF;AAAA;AAAA;AAIJ,IAAM,SAAQ,gBAAe;AAI7B,gBAAiB,YAAwB;AAjCzC;AAkCE,QAAM,UAAS,kBAAkB,IAAI,MAAM,aAAa;AACxD,QAAM,CAAE,WAAW,MAAM,QAAQ,MAAM,OAAO,MAAM,MAAM,eAAgB;AAE1E,QAAM,KAAK,CAAE,OAAO,CAAC,cAAc,QAAQ;AAC3C,QAAM,MAAM,uBAAW,WAAX,mBAAmB,QAAnB,YAA0B,CAAE,MAAM;AAC9C,QAAM,SAAS,CAAE,MAAM,OAAO,MAAM,YAAY,MAAM,IAAI;AAE1D,QAAM,QAAQ;AAAA,IACZ,aAAa;AAAA,IACb,WAAW,QAAO,SAAS;AAAA,KACxB,WAAW,QAHF;AAAA,IAIZ;AAAA,IACA,UAAU;AAAA,IACV;AAAA,IACA,eAAe;AAAA,MACb,OAAO,OAAO,YAAY,2BAA2B;AAAA,MACrD,QAAQ,sBACH,cAAc,aACd,uBAAW,UAAX,mBAAkB,kBAAlB,mBAAiC;AAAA;AAAA;AAK1C,SAAM,CAAE,MAAM,OAAO,MAAM,QAAQ,aAAa,OAAO,YAAY;AAEnE,yBAAuB,aAAa,aAAa,MAAM,QAAO,wBAAwB;AAEtF,QAAM,QAAQ,CAAE,MAAM,GAAG,SAAS,MAAM,GAAG;AAE3C,SAAO,YAAY;AAAA,IACjB,SAAS,CAAE;AAAA,IACX;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU;AAAA;AAAA;AAKd,yBAA0B;AACxB,SAAO,QAAQ,IAAI;AAAA;AAGrB,uBAAwB;AAEtB,QAAM,iBAAiB,CAAC,QAAgB,CAAC,CAAE;AACzC,UAAM,YAAY,SAAS,MAAM,MAAM,KAAK;AAC5C,WAAO,MAAM,KAAK,WAAW,GAAG,oBAAoB;AAAA;AAGtD,SAAO;AAAA,IACL,gBAAgB,eAAe;AAAA,IAC/B,gBAAgB,eAAe;AAAA,IAC/B,gBAAgB,eAAe;AAAA;AAAA;",
  "names": []
}
